#!/usr/bin/env bash
# This script was generated by bashly 1.2.6 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
	printf "bash version 4 or higher is required\n" >&2
	exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
	echo "$version"
}

# :command.usage
ctl_usage() {
	printf "ctl\n\n"

	printf "%s\n" "Usage:"
	printf "  ctl COMMAND\n"
	printf "  ctl [COMMAND] --help | -h\n"
	printf "  ctl --version | -v\n"
	echo
	# :command.usage_commands
	printf "%s\n" "Commands:"
	printf "  %s   Regenerate ctl script.\n" "bashly "
	printf "  %s   Run repository seutp.\n" "setup  "
	printf "  %s   Run formatting.\n" "format "
	printf "  %s   Run linting.\n" "lint   "
	printf "  %s   Run tests.\n" "test   "
	printf "  %s   Build the package.\n" "build  "
	printf "  %s   Publish the package to npm.\n" "publish"
	echo

	# :command.long_usage
	if [[ -n "$long_usage" ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo
		printf "  %s\n" "--version, -v"
		printf "    Show version number\n"
		echo

	fi
}

# :command.usage
ctl_bashly_usage() {
	printf "ctl bashly - Regenerate ctl script.\n\n"

	printf "%s\n" "Usage:"
	printf "  ctl bashly\n"
	printf "  ctl bashly --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n "$long_usage" ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
ctl_setup_usage() {
	printf "ctl setup - Run repository seutp.\n\n"

	printf "%s\n" "Usage:"
	printf "  ctl setup [OPTIONS]\n"
	printf "  ctl setup --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n "$long_usage" ]]; then
		printf "%s\n" "Options:"

		# :command.usage_flags
		# :flag.usage
		printf "  %s\n" "--lazy"
		printf "    Only perform setup if the repository does not look setup.\n"
		echo

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
ctl_format_usage() {
	printf "ctl format - Run formatting.\n\n"

	printf "%s\n" "Usage:"
	printf "  ctl format\n"
	printf "  ctl format --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n "$long_usage" ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
ctl_lint_usage() {
	printf "ctl lint - Run linting.\n\n"

	printf "%s\n" "Usage:"
	printf "  ctl lint\n"
	printf "  ctl lint --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n "$long_usage" ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
ctl_test_usage() {
	printf "ctl test - Run tests.\n\n"

	printf "%s\n" "Usage:"
	printf "  ctl test\n"
	printf "  ctl test --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n "$long_usage" ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
ctl_build_usage() {
	printf "ctl build - Build the package.\n\n"

	printf "%s\n" "Usage:"
	printf "  ctl build\n"
	printf "  ctl build --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n "$long_usage" ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
ctl_publish_usage() {
	printf "ctl publish - Publish the package to npm.\n\n"

	printf "%s\n" "Usage:"
	printf "  ctl publish\n"
	printf "  ctl publish --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n "$long_usage" ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
	local arg passthru flags
	passthru=false

	while [[ $# -gt 0 ]]; do
		arg="$1"
		if [[ $passthru == true ]]; then
			input+=("$arg")
		elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
			input+=("${BASH_REMATCH[1]}")
			input+=("${BASH_REMATCH[2]}")
		elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
			input+=("${BASH_REMATCH[1]}")
			input+=("${BASH_REMATCH[2]}")
		elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
			flags="${BASH_REMATCH[1]}"
			for ((i = 0; i < ${#flags}; i++)); do
				input+=("-${flags:i:1}")
			done
		elif [[ "$arg" == "--" ]]; then
			passthru=true
			input+=("$arg")
		else
			input+=("$arg")
		fi

		shift
	done
}

# :command.inspect_args
inspect_args() {
	if ((${#args[@]})); then
		readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
		echo args:
		for k in "${sorted_keys[@]}"; do
			echo "- \${args[$k]} = ${args[$k]}"
		done
	else
		echo args: none
	fi

	if ((${#other_args[@]})); then
		echo
		echo other_args:
		echo "- \${other_args[*]} = ${other_args[*]}"
		for i in "${!other_args[@]}"; do
			echo "- \${other_args[$i]} = ${other_args[$i]}"
		done
	fi

	if ((${#deps[@]})); then
		readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
		echo
		echo deps:
		for k in "${sorted_keys[@]}"; do
			echo "- \${deps[$k]} = ${deps[$k]}"
		done
	fi

	if ((${#env_var_names[@]})); then
		readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
		echo
		echo "environment variables:"
		for k in "${sorted_names[@]}"; do
			echo "- \$$k = ${!k:-}"
		done
	fi
}

# :command.command_functions
# :command.function
ctl_bashly_command() {

	# src/bashly_command.sh
	# shellcheck shell=bash

	root=$(git rev-parse --show-toplevel)
	(cd "$root/ctl" && bashly generate)
	direnv reload

}

# :command.function
ctl_setup_command() {

	# src/setup_command.sh
	# shellcheck shell=bash

	set -eo pipefail

	set +o nounset
	lazy="${args[--lazy]}"
	set -o nounset

	root=$(git rev-parse --show-toplevel)
	if [ ! "$lazy" ] || [ ! -d "${root}/node_modules" ]; then
		echo "running npm install"
		npm install
	fi

	set +eo pipefail

}

# :command.function
ctl_format_command() {

	# src/format_command.sh
	# shellcheck shell=bash

	set -eo pipefail

	root=$(git rev-parse --show-toplevel)

	if [ ! -d "${root}/node_modules" ]; then
		npm install
	fi

	npm run format

	set +eo pipefail

}

# :command.function
ctl_lint_command() {

	# src/lint_command.sh
	# shellcheck shell=bash

	set -eo pipefail

	root=$(git rev-parse --show-toplevel)

	if [ ! -d "${root}/node_modules" ]; then
		npm install
	fi

	npm run lint

	set +eo pipefail

}

# :command.function
ctl_test_command() {

	# src/test_command.sh
	# shellcheck shell=bash

	set -eo pipefail

	root=$(git rev-parse --show-toplevel)

	if [ ! -d "${root}/node_modules" ]; then
		npm install
	fi

	npm run test

	set +eo pipefail

}

# :command.function
ctl_build_command() {

	# src/build_command.sh
	# shellcheck shell=bash

	set -eo pipefail

	root=$(git rev-parse --show-toplevel)

	if [ ! -d "${root}/node_modules" ]; then
		npm install
	fi

	npm run build

	set +eo pipefail

}

# :command.function
ctl_publish_command() {

	# src/publish_command.sh
	# shellcheck shell=bash

	set -eo pipefail

	root=$(git rev-parse --show-toplevel)

	if [ ! -d "${root}/node_modules" ]; then
		npm install
	fi

	ctl format

	# We do not want to proceed with publishing if there are uncommitted changes.
	if [ -n "$(git status --porcelain)" ]; then
		echo "unable to publish as there are uncommitted changes"
		exit 1
	fi

	ctl lint
	ctl test
	ctl build

	npm run publish

	version=$(jq -r '.version' "$root/package.json")
	tag="v$version"
	git tag "$tag"
	git push origin "$tag"

	set +eo pipefail

}

# :command.parse_requirements
parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			--version | -v)
				version_command
				exit
				;;

			--help | -h)
				long_usage=yes
				ctl_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action=${1:-}

	case $action in
		-*) ;;

		bashly)
			action="bashly"
			shift
			ctl_bashly_parse_requirements "$@"
			shift $#
			;;

		setup)
			action="setup"
			shift
			ctl_setup_parse_requirements "$@"
			shift $#
			;;

		format)
			action="format"
			shift
			ctl_format_parse_requirements "$@"
			shift $#
			;;

		lint)
			action="lint"
			shift
			ctl_lint_parse_requirements "$@"
			shift $#
			;;

		test)
			action="test"
			shift
			ctl_test_parse_requirements "$@"
			shift $#
			;;

		build)
			action="build"
			shift
			ctl_build_parse_requirements "$@"
			shift $#
			;;

		publish)
			action="publish"
			shift
			ctl_publish_parse_requirements "$@"
			shift $#
			;;

		# :command.command_fallback
		"")
			ctl_usage >&2
			exit 1
			;;

		*)
			printf "invalid command: %s\n" "$action" >&2
			exit 1
			;;

	esac

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
ctl_bashly_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			--help | -h)
				long_usage=yes
				ctl_bashly_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="bashly"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
ctl_setup_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			--help | -h)
				long_usage=yes
				ctl_setup_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="setup"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			# :flag.case
			--lazy)

				# :flag.case_no_arg
				args['--lazy']=1
				shift
				;;

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
ctl_format_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			--help | -h)
				long_usage=yes
				ctl_format_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="format"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
ctl_lint_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			--help | -h)
				long_usage=yes
				ctl_lint_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="lint"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
ctl_test_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			--help | -h)
				long_usage=yes
				ctl_test_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="test"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
ctl_build_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			--help | -h)
				long_usage=yes
				ctl_build_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="build"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
ctl_publish_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			--help | -h)
				long_usage=yes
				ctl_publish_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="publish"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.initialize
initialize() {
	version="1.0.0"
	long_usage=''
	set -e

}

# :command.run
run() {
	declare -g -A args=()
	declare -g -A deps=()
	declare -g -a other_args=()
	declare -g -a env_var_names=()
	declare -g -a input=()
	normalize_input "$@"
	parse_requirements "${input[@]}"

	case "$action" in
		"bashly") ctl_bashly_command ;;
		"setup") ctl_setup_command ;;
		"format") ctl_format_command ;;
		"lint") ctl_lint_command ;;
		"test") ctl_test_command ;;
		"build") ctl_build_command ;;
		"publish") ctl_publish_command ;;
	esac
}

initialize
run "$@"
